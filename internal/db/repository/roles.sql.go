// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRole = `-- name: CreateRole :one
INSERT INTO roles (
  id,
  organisation_id,
  name,
  description,
  base_role_id
) VALUES (
  $1, 
  $2, 
  $3, 
  $4,
  $5
) RETURNING id, organisation_id, name, base_role_id, description
`

type CreateRoleParams struct {
	ID             string      `json:"id"`
	OrganisationID pgtype.Text `json:"organisation_id"`
	Name           string      `json:"name"`
	Description    pgtype.Text `json:"description"`
	BaseRoleID     pgtype.Text `json:"base_role_id"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.ID,
		arg.OrganisationID,
		arg.Name,
		arg.Description,
		arg.BaseRoleID,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.Name,
		&i.BaseRoleID,
		&i.Description,
	)
	return i, err
}

const createRolePermission = `-- name: CreateRolePermission :exec
INSERT INTO role_permissions (role_id, permission_key, allowed)
VALUES ($1, $2, $3)
RETURNING role_id, permission_key, allowed
`

type CreateRolePermissionParams struct {
	RoleID        string      `json:"role_id"`
	PermissionKey string      `json:"permission_key"`
	Allowed       pgtype.Bool `json:"allowed"`
}

func (q *Queries) CreateRolePermission(ctx context.Context, arg CreateRolePermissionParams) error {
	_, err := q.db.Exec(ctx, createRolePermission, arg.RoleID, arg.PermissionKey, arg.Allowed)
	return err
}

const getDefaultRole = `-- name: GetDefaultRole :one
SELECT r.id, r.organisation_id, r.name, r.base_role_id, r.description
FROM roles AS r
JOIN organisations AS o ON o.default_role_id = r.id
WHERE o.id = $1
LIMIT 1
`

func (q *Queries) GetDefaultRole(ctx context.Context, id string) (Role, error) {
	row := q.db.QueryRow(ctx, getDefaultRole, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.Name,
		&i.BaseRoleID,
		&i.Description,
	)
	return i, err
}

const getGlobalRoles = `-- name: GetGlobalRoles :many
SELECT id, organisation_id, name, base_role_id, description FROM roles
WHERE organisation_id IS NULL
ORDER BY name
`

func (q *Queries) GetGlobalRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, getGlobalRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.Name,
			&i.BaseRoleID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsForRole = `-- name: GetPermissionsForRole :many
SELECT role_id, permission_key, allowed FROM role_permissions
WHERE role_id = $1
`

func (q *Queries) GetPermissionsForRole(ctx context.Context, roleID string) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, getPermissionsForRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolePermission{}
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(&i.RoleID, &i.PermissionKey, &i.Allowed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, organisation_id, name, base_role_id, description
FROM roles
WHERE id = $1 AND organisation_id = $2
LIMIT 1
`

type GetRoleByIDParams struct {
	ID             string      `json:"id"`
	OrganisationID pgtype.Text `json:"organisation_id"`
}

func (q *Queries) GetRoleByID(ctx context.Context, arg GetRoleByIDParams) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByID, arg.ID, arg.OrganisationID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.Name,
		&i.BaseRoleID,
		&i.Description,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, organisation_id, name, base_role_id, description
FROM roles
WHERE name = $1 AND organisation_id = $2
LIMIT 1
`

type GetRoleByNameParams struct {
	Name           string      `json:"name"`
	OrganisationID pgtype.Text `json:"organisation_id"`
}

func (q *Queries) GetRoleByName(ctx context.Context, arg GetRoleByNameParams) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, arg.Name, arg.OrganisationID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.Name,
		&i.BaseRoleID,
		&i.Description,
	)
	return i, err
}

const getRolesForOrg = `-- name: GetRolesForOrg :many
SELECT id, organisation_id, name, base_role_id, description FROM roles
WHERE organisation_id = $1
ORDER BY name
`

func (q *Queries) GetRolesForOrg(ctx context.Context, organisationID pgtype.Text) ([]Role, error) {
	rows, err := q.db.Query(ctx, getRolesForOrg, organisationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.Name,
			&i.BaseRoleID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPermission = `-- name: HasPermission :one
SELECT EXISTS (
    SELECT 1
    FROM organisation_members AS m
    JOIN role_permissions AS p ON p.role_id = m.role_id
    WHERE m.user_id = $1
      AND m.organisation_id = $2
      AND p.permission_key = $3
      AND p.allowed = TRUE
) AS has_permission
`

type HasPermissionParams struct {
	UserID         string `json:"user_id"`
	OrganisationID string `json:"organisation_id"`
	PermissionKey  string `json:"permission_key"`
}

func (q *Queries) HasPermission(ctx context.Context, arg HasPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasPermission, arg.UserID, arg.OrganisationID, arg.PermissionKey)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}
