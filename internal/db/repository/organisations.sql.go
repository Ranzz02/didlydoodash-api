// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organisations.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOrganisations = `-- name: CountOrganisations :one
SELECT COUNT(*) FROM organisations
`

func (q *Queries) CountOrganisations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrganisations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganisation = `-- name: CreateOrganisation :one
INSERT INTO organisations (id, name, slug, owner_id)
VALUES ($1, $2, $3, $4)
RETURNING id, name, slug, description, owner_id, website, logo_url, location, timezone, is_active, archived_at, settings, created_at, updated_at
`

type CreateOrganisationParams struct {
	ID      string `json:"id"`
	Name    string `json:"name"`
	Slug    string `json:"slug"`
	OwnerID string `json:"owner_id"`
}

func (q *Queries) CreateOrganisation(ctx context.Context, arg CreateOrganisationParams) (Organisation, error) {
	row := q.db.QueryRow(ctx, createOrganisation,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.OwnerID,
	)
	var i Organisation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.OwnerID,
		&i.Website,
		&i.LogoUrl,
		&i.Location,
		&i.Timezone,
		&i.IsActive,
		&i.ArchivedAt,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrganisation = `-- name: DeleteOrganisation :exec
DELETE FROM organisations WHERE id = $1
`

func (q *Queries) DeleteOrganisation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteOrganisation, id)
	return err
}

const getOrganisationByID = `-- name: GetOrganisationByID :one
SELECT id, name, slug, description, owner_id, website, logo_url, location, timezone, is_active, archived_at, settings, created_at, updated_at FROM organisations WHERE id = $1
`

func (q *Queries) GetOrganisationByID(ctx context.Context, id string) (Organisation, error) {
	row := q.db.QueryRow(ctx, getOrganisationByID, id)
	var i Organisation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.OwnerID,
		&i.Website,
		&i.LogoUrl,
		&i.Location,
		&i.Timezone,
		&i.IsActive,
		&i.ArchivedAt,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganisationBySlug = `-- name: GetOrganisationBySlug :one
SELECT id, name, slug, description, owner_id, website, logo_url, location, timezone, is_active, archived_at, settings, created_at, updated_at FROM organisations WHERE slug = $1
`

func (q *Queries) GetOrganisationBySlug(ctx context.Context, slug string) (Organisation, error) {
	row := q.db.QueryRow(ctx, getOrganisationBySlug, slug)
	var i Organisation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.OwnerID,
		&i.Website,
		&i.LogoUrl,
		&i.Location,
		&i.Timezone,
		&i.IsActive,
		&i.ArchivedAt,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganisationsByOwner = `-- name: GetOrganisationsByOwner :many
SELECT id, name, slug, description, owner_id, website, logo_url, location, timezone, is_active, archived_at, settings, created_at, updated_at FROM organisations
WHERE owner_id = $1
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type GetOrganisationsByOwnerParams struct {
	OwnerID string `json:"owner_id"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) GetOrganisationsByOwner(ctx context.Context, arg GetOrganisationsByOwnerParams) ([]Organisation, error) {
	rows, err := q.db.Query(ctx, getOrganisationsByOwner, arg.OwnerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organisation{}
	for rows.Next() {
		var i Organisation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.OwnerID,
			&i.Website,
			&i.LogoUrl,
			&i.Location,
			&i.Timezone,
			&i.IsActive,
			&i.ArchivedAt,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrganisations = `-- name: GetUserOrganisations :many
SELECT DISTINCT o.id, o.name, o.slug, o.description, o.owner_id, o.website, o.logo_url, o.location, o.timezone, o.is_active, o.archived_at, o.settings, o.created_at, o.updated_at
FROM organisations o
LEFT JOIN organisation_members m
  ON m.organisation_id = o.id
WHERE
  (o.owner_id = $1
   OR m.user_id = $1)
  AND (
    $2::text = ''
    OR o.name ILIKE '%' || $2::text || '%'
    OR o.slug ILIKE '%' || $2::text || '%'
  )
ORDER BY o.created_at DESC
LIMIT $4
OFFSET $3
`

type GetUserOrganisationsParams struct {
	UserID string `json:"user_id"`
	Search string `json:"search"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetUserOrganisations(ctx context.Context, arg GetUserOrganisationsParams) ([]Organisation, error) {
	rows, err := q.db.Query(ctx, getUserOrganisations,
		arg.UserID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organisation{}
	for rows.Next() {
		var i Organisation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.OwnerID,
			&i.Website,
			&i.LogoUrl,
			&i.Location,
			&i.Timezone,
			&i.IsActive,
			&i.ArchivedAt,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOrganisations = `-- name: SearchOrganisations :many
SELECT id, name, slug, description, owner_id, website, logo_url, location, timezone, is_active, archived_at, settings, created_at, updated_at FROM organisations
WHERE (
    $1::text = '' 
    OR name ILIKE '%' || $1::text || '%' 
    OR slug ILIKE '%' || $1::text || '%'
)
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type SearchOrganisationsParams struct {
	Search string `json:"search"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) SearchOrganisations(ctx context.Context, arg SearchOrganisationsParams) ([]Organisation, error) {
	rows, err := q.db.Query(ctx, searchOrganisations, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Organisation{}
	for rows.Next() {
		var i Organisation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.OwnerID,
			&i.Website,
			&i.LogoUrl,
			&i.Location,
			&i.Timezone,
			&i.IsActive,
			&i.ArchivedAt,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganisation = `-- name: UpdateOrganisation :one
UPDATE organisations
SET
    name        = COALESCE($1, name),
    slug        = COALESCE($2, slug),
    description = COALESCE($3, description),
    website     = COALESCE($4, website),
    logo_url    = COALESCE($5, logo_url),
    location    = COALESCE($6, location),
    timezone    = COALESCE($7, timezone),
    is_active   = COALESCE($8, is_active),
    archived_at = COALESCE($9, archived_at),
    updated_at  = NOW()
WHERE id = $10
RETURNING id, name, slug, description, owner_id, website, logo_url, location, timezone, is_active, archived_at, settings, created_at, updated_at
`

type UpdateOrganisationParams struct {
	Name        pgtype.Text        `json:"name"`
	Slug        pgtype.Text        `json:"slug"`
	Description pgtype.Text        `json:"description"`
	Website     pgtype.Text        `json:"website"`
	LogoUrl     pgtype.Text        `json:"logo_url"`
	Location    pgtype.Text        `json:"location"`
	Timezone    pgtype.Text        `json:"timezone"`
	IsActive    pgtype.Bool        `json:"is_active"`
	ArchivedAt  pgtype.Timestamptz `json:"archived_at"`
	ID          string             `json:"id"`
}

func (q *Queries) UpdateOrganisation(ctx context.Context, arg UpdateOrganisationParams) (Organisation, error) {
	row := q.db.QueryRow(ctx, updateOrganisation,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Website,
		arg.LogoUrl,
		arg.Location,
		arg.Timezone,
		arg.IsActive,
		arg.ArchivedAt,
		arg.ID,
	)
	var i Organisation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.OwnerID,
		&i.Website,
		&i.LogoUrl,
		&i.Location,
		&i.Timezone,
		&i.IsActive,
		&i.ArchivedAt,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
